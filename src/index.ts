/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

export = contentDisposition;

/**
 * Create an attachment Content-Disposition header.
 */
function contentDisposition(
  filename?: string,
  options?: contentDisposition.Options,
): string {
  // get type
  const type = options?.type || 'attachment';

  // get parameters
  const params = createparams(filename, options?.fallback);

  // format into string
  return format(new ContentDispositionImpl(type, params));
}

namespace contentDisposition {
  export interface ContentDisposition {
    /**
     * Content-Disposition type, such as "attachment" or "inline"
     */
    type: string;
    /**
     * Content-Disposition parameters, such as "filename"
     */
    parameters: Record<string, string>;
  }

  export interface Options {
    /**
     * Content-Disposition type, defaults to "attachment"
     * @default "attachment"
     */
    type?: string;
    /**
     * Fallback filename for non-ISO-8859-1 strings. If true, a fallback will be generated by replacing non-latin1 characters with "?". If false, no fallback will be generated.
     * @default true
     */
    fallback?: string | boolean;
  }

  /**
   * Parse Content-Disposition header string.
   */
  export function parse(string: string): ContentDisposition {
    if (!string || typeof string !== 'string') {
      throw new TypeError('argument string is required');
    }

    let match = DISPOSITION_TYPE_REGEXP.exec(string);

    if (!match) {
      throw new TypeError('invalid type format');
    }

    // normalize type
    let index = match[0].length;
    const type = match[1].toLowerCase();

    const obj = new ContentDispositionImpl(type);

    let key;
    const names = [];
    let value;

    // calculate index to start at
    index = PARAM_REGEXP.lastIndex =
      match[0].slice(-1) === ';' ? index - 1 : index;

    // match parameters
    while ((match = PARAM_REGEXP.exec(string))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }

      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];

      if (names.indexOf(key) !== -1) {
        throw new TypeError('invalid duplicate parameter');
      }

      names.push(key);

      if (key.indexOf('*') + 1 === key.length) {
        // decode extended value
        key = key.slice(0, -1);
        value = decodefield(value);

        // overwrite existing value
        obj.parameters[key] = value;
        continue;
      }

      if (typeof obj.parameters[key] === 'string') {
        continue;
      }

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.slice(1, -1).replace(QESC_REGEXP, '$1');
      }

      obj.parameters[key] = value;
    }

    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }

    return obj;
  }
}

interface FormatOptions {
  type: string;
  parameters?: Record<string, unknown>;
}

/**
 * TextDecoder instance for UTF-8 decoding when decodeURIComponent fails due to invalid byte sequences.
 */
const utf8Decoder = new TextDecoder('utf-8');

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 */
const ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

/**
 * RegExp to match non-latin1 characters.
 */
const NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
const QESC_REGEXP = /\\([\u0000-\u007f])/g; // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
const QUOTE_REGEXP = /([\\"])/g;

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
const PARAM_REGEXP =
  /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
const TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
const TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 */
const EXT_VALUE_REGEXP =
  /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 */
const DISPOSITION_TYPE_REGEXP =
  /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

/**
 * Create parameters object from filename and fallback.
 */
function createparams(
  filename?: string,
  fallback: string | boolean = true,
): Record<string, string> | undefined {
  if (filename === undefined) {
    return;
  }

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string');
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean');
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string');
  }

  const params: Record<string, string> = {};

  // restrict to file base name
  const name = basename(filename);

  // determine if name is suitable for quoted string
  const isQuotedString = TEXT_REGEXP.test(name);

  // generate fallback name
  const fallbackName =
    typeof fallback !== 'string'
      ? fallback && getlatin1(name)
      : basename(fallback);
  const hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

  // set extended filename parameter
  if (hasFallback || !isQuotedString || hasHexEscape(name)) {
    params['filename*'] = name;
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name;
  }

  return params;
}

/**
 * Decode a RFC 5987 field value (gracefully).
 */
function decodefield(str: string): string {
  const match = EXT_VALUE_REGEXP.exec(str);

  if (!match) {
    throw new TypeError('invalid extended field value');
  }

  const charset = match[1].toLowerCase();
  const encoded = match[2];

  switch (charset) {
    case 'iso-8859-1': {
      const binary = decodeHexEscapes(encoded);
      return getlatin1(binary);
    }
    case 'utf-8':
    case 'utf8': {
      try {
        return decodeURIComponent(encoded);
      } catch {
        // Failed to decode with decodeURIComponent, fallback to lenient decoding which replaces invalid UTF-8 byte sequences with the Unicode replacement character
        // TODO: Consider removing in the next major version to be more strict about invalid percent-encodings
        const binary = decodeHexEscapes(encoded);

        const bytes = new Uint8Array(binary.length);
        for (let idx = 0; idx < binary.length; idx++) {
          bytes[idx] = binary.charCodeAt(idx);
        }

        return utf8Decoder.decode(bytes);
      }
    }
  }

  throw new TypeError('unsupported charset in extended field');
}

/**
 * Format object to Content-Disposition header.
 */
function format(obj: FormatOptions): string {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }

  if (
    !obj.type ||
    typeof obj.type !== 'string' ||
    !TOKEN_REGEXP.test(obj.type)
  ) {
    throw new TypeError('invalid type');
  }

  // start with normalized type
  let string = obj.type.toLowerCase();

  // append parameters
  if (obj.parameters && typeof obj.parameters === 'object') {
    const params = Object.keys(obj.parameters).sort();

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      const val =
        param.slice(-1) === '*'
          ? ustring(obj.parameters[param])
          : qstring(obj.parameters[param]);

      string += `; ${param}=${val}`;
    }
  }

  return string;
}

/**
 * Get ISO-8859-1 version of string.
 */
function getlatin1(val: string): string {
  // simple Unicode -> ISO-8859-1 transformation
  return val.replace(NON_LATIN1_REGEXP, '?');
}

/**
 * Percent encode a single character.
 */
function pencode(char: string): string {
  return '%' + char.charCodeAt(0).toString(16).toUpperCase();
}

/**
 * Quote a string for HTTP.
 */
function qstring(val: unknown): string {
  const str = String(val);

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 */
function ustring(val: unknown): string {
  const str = String(val);

  // percent encode as UTF-8
  const encoded = encodeURIComponent(str).replace(
    ENCODE_URL_ATTR_CHAR_REGEXP,
    pencode,
  );

  return "UTF-8''" + encoded;
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 */
class ContentDispositionImpl implements contentDisposition.ContentDisposition {
  type: string;
  parameters: Record<string, string>;

  constructor(type: string, parameters?: Record<string, string>) {
    this.type = type;
    this.parameters = Object.create(null);

    if (parameters) {
      for (const [key, value] of Object.entries(parameters)) {
        this.parameters[key] = value;
      }
    }
  }
}

/**
 * Return the last portion of a path
 */
function basename(path: string): string {
  const normalized = path.replaceAll('\\', '/');

  let end = normalized.length;
  while (end > 0 && normalized[end - 1] === '/') {
    end--;
  }

  if (end === 0) {
    return '';
  }

  let start = end - 1;
  while (start >= 0 && normalized[start] !== '/') {
    start--;
  }

  return normalized.slice(start + 1, end);
}

/**
 * Check if a character is a hex digit [0-9A-Fa-f]
 */
function isHexDigit(char: string): boolean {
  const code = char.charCodeAt(0);
  return (
    (code >= 48 && code <= 57) || // 0-9
    (code >= 65 && code <= 70) || // A-F
    (code >= 97 && code <= 102) // a-f
  );
}

/**
 * Check if a string contains percent encoding escapes.
 */
function hasHexEscape(str: string): boolean {
  const maxIndex = str.length - 3;
  let lastIndex = -1;

  while (
    (lastIndex = str.indexOf('%', lastIndex + 1)) !== -1 &&
    lastIndex <= maxIndex
  ) {
    if (isHexDigit(str[lastIndex + 1]) && isHexDigit(str[lastIndex + 2])) {
      return true;
    }
  }

  return false;
}

/**
 * Decode hex escapes in a string (e.g., %20 -> space)
 */
function decodeHexEscapes(str: string): string {
  const firstEscape = str.indexOf('%');
  if (firstEscape === -1) return str;

  let result = str.slice(0, firstEscape);
  for (let idx = firstEscape; idx < str.length; idx++) {
    if (
      str[idx] === '%' &&
      idx + 2 < str.length &&
      isHexDigit(str[idx + 1]) &&
      isHexDigit(str[idx + 2])
    ) {
      result += String.fromCharCode(
        Number.parseInt(str[idx + 1] + str[idx + 2], 16),
      );
      idx += 2;
    } else {
      result += str[idx];
    }
  }
  return result;
}
